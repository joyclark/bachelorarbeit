\section{Introduction}

ProB is the name given to a group of software tools dealing with the verification of models written in formal specification languages. The main specification language that ProB deals with is the B-Method. The B-Method is a method of specifying and designing software systems that was originally created by J.R. Abrial \cite{abrial2005b}. Central to the B-Method are the concepts of \emph{abstract machines} that specify how a system should function \cite{schneider2001b}. However, ProB also provides support for the Event-B, CSP-M, TLA+, and Z specification languages. 

In order to verify a formal model, ProB simulates the state space that corresponds to that model. A \emph{state space} is a directed multigraph whose vertices represent every possible state in the system. The edges in the graph represent all of the transitions between any given states. ProB verifies a model primarily by performing \emph{consistency checking}. This is the systematic check of all states that are accessible from the initial state. A model is found to be correct if its state space contains no deadlocks (i.e. all vertices in the graph have at least one outgoing edge) and if no state violates the \emph{invariant} for the model. The \emph{invariant} is a predicate that must evaluate to true for every state in the model. The user can also use ProB to perform animation of a particular model, i.e. to interactively create a trace of states throughout the state space.

During the course of model verification, ProB produces a great deal of data. The purpose of this work is to dynamically generate visualizations based on this data. The approach for data visualization here differs from that applied in B-Motion studio \cite{LaBeLe09_258} which allows users to build visualization that then are updated when the current state in an animation changes.

\subsection{Visualization of the State Space}

Since the concept of the state space is so central to ProB, the focus of this work will be on generating a visualization of the state space. Algorithms for drawing graphs are not trivial; hence this visualization problem is not trivial. However, the focus of this work is in applying existing graph algorithms to create visualizations as opposed to writing a new algorithm or modifying an existing algorithm. Therefore, it is necessary to find a suitable library to take care of the drawing of the state space.

ProB already includes support for the creation of a graph description of the state space in the DOT graph description language. These description files can then be visualized with GraphViz\footnote{http://www.graphviz.org}. However, the graph algorithms available in GraphViz are relatively inefficient. During verification, the state space often grows exponentially. For state spaces that have a very large number of vertices, the GraphViz algorithms take too long to be useful. The graph generation in GraphViz is also inherently offline. If any thing changes in the state space, the whole graph must be rerendered. During consistency checking or animation, states are constantly being added to the graph. We therefore want a graph engine that can easily add vertices and that can handle state spaces with a large number of vertices.

We also want the user to be able to manipulate and interact with the graph. For instance, ProB supports the ability to create smaller graphs that are derived from the original state space \cite{LeTu05_8}. Because state spaces become so large so quickly, a derived graph can be much more meaningful and useful for a user. One of the features that we want to implement for the visualization of the state space is to enable the user to apply these algorithms to their state space to simplify its representation. The user should be able to seamlessly transfer between the representation of the whole state space and derived state spaces.

\subsection{Other Visualizations}

Although the visualization of the state space is the focus of this work, there are visualizations that can be generated which will be useful for the user. For instance, ProB supports the generation of a DOT file which, when rendered, shows how a given formula is broken down into subformulas \cite{LeSaBeLu08_228}. The formula and its subformulas are also evaluated for a given state, and the resulting nodes are colored so as to specify the value of the formula (e.g. if a given predicate evaluates to true at the specified state, the predicate would be colored green). During the course of this work, we will also recreate this visualization using the new graph engine.

One of the features that is currently being integrated into ProB is the simulation of multiple models concurrently. In this case, the user is less interested in viewing the state space and more interested in being able to see what value a particular expression takes on over the course of a given animation. We will therefore also create a chart to visualize this information.

\subsection{Integration of the Visualizations into ProB}

The graph engine that we have have chosen is D3. Instead of a graph engine in the traditional sense, D3 provides a domain specific language to enable the user to generate elements based on data that is provided. D3 is written in JavaScript, and the visualizations that can be produces are pure HTML and SVG documents.

The visualizations that are produced using D3 will be integrated into the ProB 2.0 Java application using the Jetty server that is already present. The visualizations will also make use of the existing listener framework that is triggered when changes in the state space or the current animation take place. It should also be possible to create and view multiple visualizations at any given time. 



%\subsection{Integration into the ProB 2.0 Eclipse Plugin}

%Because ProB 2.0 is an Eclipse plugin, it is necessary to be able to integrate any visualization into the framework. Because D3 is JavaScript based, we will create Eclipse views that contain a browser displaying the visualization that we create. A similar technique has already been used to create the groovy console view in the ProB 2.0 application.

%It is also necessary that the Java servlets responsible for generating and manipulating the visualizations can manage several different visualizations at once. We have not integrated any server side language into our webserver, so the visualizations need to consist only of static html pages and the JavaScript programs that are responsible for generating the visualization. Data will not be able to be sent to any of the visualizations directly. Instead, the JavaScript scripts will have to set up an interval to poll the servlet and ask for any changes in their visualization.

%It should also be possible for the user to edit the visualization. Using D3 selectors, it is possible to change the style of D3 visualizations. We should find a way to lift this functionality from the JavaScript level into the Java application so the user has as much control over the generated visualization as possible.

%During the course of this paper, the different tools and concepts that were necessary in the scope of this work will be introduced. Then the motivation and the requirements for the desired visualizations will be described in detail. The actual visualizations that were created will then be presented, followed by further ideas for implementations and related work.