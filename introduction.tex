\section{Introduction}

In order to understand the data that is produced by software tools, it is important to be able to represent that data in a way that users can understand. The purpose of this work is to make useful visualizations for the ProB model checker and animator. 

One of the ProB tools, the ProB Tcl/Tk application, uses the DOTTY graph layout tool to create visualizations. However, these visualizations are missing in the ProB 2.0 Java application. In this work, we intend to inspect the data visualizations that are available in the Tcl/Tk application and recreate them for ProB 2.0. 

For the scope of this work, we are not interested in inspecting algorithms for drawing graphs. We are interested in applying modern graph drawing tools with existing graph algorithms to create useful visualizations.

We will use the D3 JavaScript tool to create visualizations that will be embedded into the ProB 2.0 application using the existing Jetty webserver.


\subsection{Planned Visualizations}

The ProB 2.0 API extracts the information about the existing state space from the ProB CLI and saves it in a programmatic abstraction of the state space. This abstraction saves the information about the different states in a graph data structure using the Java JUNG graph library. The state space object already supports the use of Dijkstra's algorithm to find the shortest trace from the root state to a user defined state. This can be used to find traces that show how an invariant violation or deadlock can be found. What is missing, however, is a visualization of the actual state space itself.

Because the state space is a directed multigraph, this visualization problem is not trivial because the algorithm for drawing graphs is not trivial. We had to find a graph library that would be able to draw a such a graph. Because the state space varies drastically depending on the machine that is being animated, it was also necessary that the graph library be able to handle graphs of all different shapes and sizes. We chose D3 because it met all of these requirements.

We also wanted the user to be able to manipulate and interact with the graph. For instance, the ProB CLI supports the ability to create smaller graphs that are derived from the original state space \cite{LeTu05_8}. Because state spaces become so large so quickly, a derived graph can be much more meaningful and useful for a user. One of the features that we want to implement for the state space visualization is the ability for the user to apply these algorithms to their state space to simplify its representation. The calculation of these algorithms needs to take place in the ProB CLI, but a seamless transfer between the two graphs should take place from within the visualization.

Although the visualization of the state space is the focus of this work, there are other sets of data that need to be visualized. The ProB Tcl/Tk version supports a useful visualization of B formulas \cite{LeSaBeLu08_228}. The user specified formula is broken down into subformulas and colored so as to specify the value of the formula (e.g. if a given predicate evaluates to true at the specified state, the predicate would be colored green). A similar visualization exists in the ProB Plugin, but not in ProB 2.0.

We also wanted to create a visualization of the value of a user defined formula over the course of an animation. No such visualization exists in any of the ProB applications yet, but it is especially useful for visualizing cosimulation and continuous models.

\subsection{Integration into the ProB 2.0 Eclipse Plugin}

Because ProB 2.0 is an Eclipse plugin, it is necessary to be able to integrate any visualization into the framework. Because D3 is JavaScript based, we will create Eclipse views that contain a browser displaying the visualization that we create. A similar technique has already been used to create the groovy console view in the ProB 2.0 application.

It is also necessary that the Java servlets responsible for generating and manipulating the visualizations can manage several different visualizations at once. We have not integrated any server side language into our webserver, so the visualizations need to consist only of static html pages and the JavaScript programs that are responsible for generating the visualization. Data will not be able to be sent to any of the visualizations directly. Instead, the JavaScript scripts will have to set up an interval to poll the servlet and ask for any changes in their visualization.

It should also be possible for the user to edit the visualization. Using D3 selectors, it is possible to change the style of D3 visualizations. We should find a way to lift this functionality from the JavaScript level into the Java application so the user has as much control over the generated visualization as possible.

During the course of this paper, the different tools and concepts that were necessary in the scope of this work will be introduced. Then the motivation and the requirements for the desired visualizations will be described in detail. The actual visualizations that were created will then be presented, followed by further ideas for implementations and related work.