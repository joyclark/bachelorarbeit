\section{Introduction}

ProB is a tool created for the animation and verification of formal methods, in particular for models that are created using the B-Method \cite{LeBu03_32}. The B-Method is a method of specifying and designing software systems that was originally created by J.R. Abrial \cite{abrial2005b}. Central to the B-Method are the concepts of \emph{abstract machines} that specify how a system should function \cite{schneider2001b}. Specifications created using the B-Method are written in Classical B or Event-B notation. One of the main use cases for the B-Method is to model and verify that safety-critical software is correct. ProB also provides support for the verification of the CSP, TLA+, and Z specification languages.

In order to verify a formal specification, ProB simulates the state space that corresponds to that model. A \emph{state space} is a labeled transition system that is represented as a directed multigraph. The vertices in the graph represent every possible state in the system. The edges in the graph represent all of the transitions between any given states. ProB verifies a model primarily by performing \emph{consistency checking}. This is the systematic check of all states that are accessible from the initial state. A model is found to be correct if its state space contains no deadlocks (i.e. all vertices in the graph have at least one outgoing edge) and if no state violates the \emph{invariant} for the model. The \emph{invariant} is a predicate that describes the correct behavior of the model and that must evaluate to true for every state in the model in order for the model to be correct. 

The user can also use ProB to perform animation of a particular model. \emph{Animation} here refers to the user's ability to interactively select transitions and thereby create a path throughout the state space. When animating, the concept of a \emph{current state} becomes important. The \emph{current state} refers to the state in the state space that the user has reached after executing all of the transitions that the user has specified during animation. It is often of interest to the user to be able to examine elements of the model at the current state in the animation.

During the course of model verification, ProB produces a great deal of data. The purpose of this work is to dynamically generate visualizations based upon this data. The approach for data visualization here differs from the method that is applied in B-Motion studio \cite{LaBeLe09_258}, which allows users to build visualizations that then are updated when the current state in an animation changes.
% Maybe move this sentence to related work?

\subsection{Visualization of the State Space}

Since the concept of the state space is so central to ProB, the focus of this work will be on generating a visualization of the state space. Algorithms for drawing graphs are not trivial; hence this visualization problem is not trivial. However, the focus of this work is in applying existing graph algorithms to create visualizations as opposed to writing a new algorithm or modifying an existing algorithm. Therefore, it is necessary to find an existing library that is able to take care of the drawing of the state space.

ProB already includes support for the creation of a graph description of the state space in the DOT graph description language. These description files can then be visualized with GraphViz\footnote{http://www.graphviz.org}. However, the graph algorithms available in GraphViz are relatively inefficient. During verification, the state space often grows exponentially. For state spaces that have a very large number of vertices, the GraphViz algorithms take too long to be useful. The graph generation in GraphViz is also inherently offline. If any thing changes in the state space, the whole graph must be rerendered. Consequently, the generated graphs can be very different from each other, and the user can lose track of the area of the state space that is of interest to him. During consistency checking and animation, states are constantly being added to the graph. We therefore want a graph engine that can easily add vertices to an existing visualization and that can handle state spaces with a large number of vertices.

We also want the user to be able to manipulate and interact with the graph. For instance, ProB supports the ability to create smaller graphs that are derived from the original state space \cite{LeTu05_8}. Because state spaces become so large so quickly, a derived graph can be much more meaningful and useful for a user. In our visualization of the state space, we have enabled the user to apply these algorithms to their state space to simplify its representation. The user can also seamlessly transfer between the representation of the whole state space and the derived graphs.

\subsection{Other Visualizations}

Although the visualization of the state space is the focus of this work, there are other visualizations that can be generated which will be useful for the user. For instance, ProB supports the generation of a DOT file which, when rendered, shows how a given formula is broken down into subformulas \cite{LeSaBeLu08_228}. The formula and its subformulas are also evaluated for a given state, and the resulting represenation of the formula is colored so as to specify its value (e.g. if a given predicate evaluates to true at the specified state, the predicate is colored green). During the course of this work, we also have recreated this visualization using the new graph engine.

Currently, one of the points of interest in the development of ProB is the simulation of time. This can be the simulation of models with a temporal element or the simulation of multiple models concurrently. When this is the case, the user is less interested in the state space for the given model and more interested in being able to see what value that a model element takes on over the course of a given animation. We have therefore also created a line chart to visualize this information.

\subsection{Integration of the Visualizations into ProB}

The library that we have chosen to take care of the generation of our visualizations is the JavaScript library D3. D3 provides a modern approach to data visualization. Instead of defining a unique grammar and a rendering engine to draw visualizations, D3 provides the user with the ability to create and position HTML and SVG elements within an HTML document. The resulting images can then be rendered by any modern browser and can be styled using CSS. Because D3 is a JavaScript library, it is also possible to update the visualizations dynamically. 

The visualizations that are produced using D3 are integrated into the ProB 2.0 Java application using the internal Jetty server that is present. The visualizations also make use of the existing listener framework that is triggered when changes in the state space or the current animation take place. It is also possible to create and view multiple visualizations at any given time. 