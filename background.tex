\section{Background}

\subsection{B-Method}

The B-Method is a method of specifying and designing software systems that was originally created by J.R. Abrial \cite{abrial2005b}. Central to the B-Method are the concepts of \emph{abstract machines} that specify how a system should function \cite{schneider2001b}.

An \emph{abstract machine} describes how a particular component should work. In order to do this, the machine specifies \emph{operations} which describe how the machine should work. An \emph{operation} can change the \emph{state} of the machine. A \emph{state} is a set of \emph{variables} that are constrained by an \emph{invariant}. In order for the model to be valid, the \emph{invariant} must evaluate to true for every state in the model.

Two specification languages used within the scope of the B-Method are Classical B and Event-B. There are several tools available to check and verify these specification languages [LIST TOOLS].

\subsection{ProB}

ProB is a tool created to verify formal specifications \cite{LeBu03_32}. In addition to verifying Classical B and Event-B specifications, ProB also verifies models written in the CSP-M, TLA+, and Z specification languages. ProB differs from other tools dealing with model verification in that it is fully automated. Several tools have also been written to extend ProB and add functionality.

ProB verifies models through consistency checking and animation. Conistency checking is the systematic check of all states within a particular specification. In order to do this, ProB checks the state space of the specification in question. The state space is a graph with \emph{states} saved as vertices and \emph{operations} saved as edges.

ProB is a model checker and animator for specifications written in the Classical B, Event-B, CSP-M, TLA+, and Z specification languages \cite{LeBu03_32}. There is a standalone version of the ProB software available with the graphical user interface written in Tcl/Tk. A binary command-line interface is also available for the software. 

In 2006, a project began to develop a ProB plug-in for the Rodin software suite so that ProB could be used in conjunction with Rodin. 

In the fall of 2011, planning for the ProB 2.0 API began.  The main goal of the ProB 2.0 API was to adapt and optimize the existing Java API to build a user interface on top of a programmatic API. Functional programming techniques were used in the development of the software as much as possible. To meet these ends, the Groovy scripting language was heavily integrated into to the ProB 2.0 core. The ProB 2.0 API includes a fully functional webserver with servlets that allow the extension of the Java core into JavaScript and HTML. The fully functional webconsole available in the API makes use of this technology.

\subsection{D3 and JavaScript}

Since a web server was already available in the ProB 2.0 application, it was plausible to create visualizations using javascript and HTML. The ProB 2.0 application is an Eclipse application, so it also would have been possible to create visualizations using a native Java or Eclipse library. I carried out an experiment at the beginning of this work to determine the feasibility of the different graph libraries. JUNG was considered because it is the software framework that is the ProB 2.0 API currently uses, but it was discarded because of the difficulty of embedding Swing visualizations into Eclipse applications. The ZEST graph library was a feasible option, but in the end, I chose to use the D3 library. 

D3 (Data-Driven Documents) is an open source JavaScript library that was developed by Bostock, Ogievetsky, and Heer for the visualization of different types of data \cite{2011-d3}. The output of the D3 functions is a pure SVG and HTML document object model that implements the W3C Selectors API. Because of this, the entire docmument can be styled using CSS and the developer has complete control over the appearance of the final product. 

Using D3 also allowed the developer to have more control over how the content is updated. One of the main features of the ProB 2.0 API is its ability to manipulate its data structures dynamically through the use of the scripting language groovy. Because the D3 visualizations are written in Javascript, the thought was to give the user similar control over the visualizations. Using D3 selectors, it is easy to select the exact SVG and HTML elements of your visualization that you want to edit. Then you add or manipulate the attributes of the selected elements to obtain the desired visualization. It would also be theoretically possible to lift some of the functionality of the selectors from the Javascript level into the Java core. Then the user would be able to manipulate the visualization using the Groovy scripting language.

D3 includes an API for visualizing many different kinds of data sets. Simple examples support for pie charts, line graphs, and bar graphs. More complex data structures such as the graph and tree data structures can be represented using the spring and tree layouts respectively. Extensive reference materials and examples are available on the D3 website.

\subsubsection{Spring Layout}

For the visualization of graphs, d3 has made the Spring layout available. The algorithm used for the layout algorithm is based on the work of Dwyer and Jakobsen (\cite{Jakobsen03},\cite{Dwyer2009}).

\subsubsection{Tree Layout}

In order to visualize trees, d3 has made the tree layout available. It is also relatively easy to build in a function so that the different nodes in the tree can be expanded or hidden.

\subsubsection{Graphs and Charts}

Preparing the data for charts is as simple as generating the data points that are to be visualized. D3 includes support for determining and drawing the needed scale for the x and y access.  