\section{Background}

\subsection{B-Method}

The B-Method is a method of specifying and designing software systems that was originally created by J.R. Abrial \cite{abrial2005b}. Central to the B-Method are the concepts of \emph{abstract machines} that specify how a system should function \cite{schneider2001b}.

An \emph{abstract machine} describes how a particular component should work. In order to do this, the machine specifies \emph{operations} which describe how the machine should work. An \emph{operation} can change the \emph{state} of the machine. A \emph{state} is a set of \emph{variables} that are constrained by an \emph{invariant}. In order for the model to be valid, the \emph{invariant} must evaluate to true for every state in the model.

Two specification languages used within the scope of the B-Method are Classical B and Event-B. There are several tools available to check and verify these specification languages [LIST TOOLS].

\subsection{ProB}

ProB is a tool created to verify formal specifications \cite{LeBu03_32}. In addition to verifying Classical B and Event-B specifications, ProB also verifies models written in the CSP-M, TLA+, and Z specification languages. ProB differs from other tools dealing with model verification in that it is fully automated. Several tools have also been written to extend ProB and add functionality.

ProB verifies models through consistency checking and animation. Conistency checking is the systematic check of all states within a particular specification. In order to do this, ProB checks the state space of the specification in question. The state space is a graph with \emph{states} saved as vertices and \emph{operations} saved as edges.

ProB is a model checker and animator for specifications written in the Classical B, Event-B, CSP-M, TLA+, and Z specification languages \cite{LeBu03_32}. There is a standalone version of the ProB software available with the graphical user interface written in Tcl/Tk. A binary command-line interface is also available for the software. 

In 2006, a project began to develop a ProB plug-in for the Rodin software suite so that ProB could be used in conjunction with Rodin. 

In the fall of 2011, planning for the ProB 2.0 API began.  The main goal of the ProB 2.0 API was to adapt and optimize the existing Java API to build a user interface on top of a programmatic API. Functional programming techniques were used in the development of the software as much as possible. To meet these ends, the Groovy scripting language was heavily integrated into to the ProB 2.0 core. The ProB 2.0 API includes a fully functional webserver with servlets that allow the extension of the Java core into JavaScript and HTML. The fully functional webconsole available in the API makes use of this technology.

\subsection{D3 and JavaScript}

Since a web server was already available in the ProB 2.0 application, it was plausible to create visualizations using javascript and HTML. The ProB 2.0 application is an Eclipse application, so it also would have been possible to create visualizations using a native Java or Eclipse library. I carried out an experiment at the beginning of this work to determine the feasibility of the different graph libraries. JUNG was considered because it is the software framework that is the ProB 2.0 API currently uses, but it was discarded because of the difficulty of embedding Swing visualizations into Eclipse applications. The ZEST graph library was a feasible option, but in the end, I chose to use the D3 library. 

D3 (Data-Driven Documents) is ``an embedded domain-specific language for transforming
the document object model based on data'' which is written in JavaScript \cite{2011-d3}. Developers can embed the library into a JavaScript application and use the D3 functions to create a pure SVG and HTML document object model. The focus of D3 is not on creating data visualizations. It is on providing the user the capability of defining exactly which elements the DOM should contain based on the data that the user has provided. Because the objects that are being manipulated are pure SVG and HTML, the user can use D3 to create objects that can be styled using CSS or by dynamically manipulating the style tags of the elements.

\subsubsection{Core Functionality}

D3 provides a selector API based on CSS3 that is similar to jQuery \cite{jQuery}. The user creates visualizations by selecting sections of the document and binding them to user provided data in the form of an array of arbitrary values \cite{2011-d3}. D3 provides support for parsing JSON, XML, HTML, CSV, and TSV files. Once the data is bound to the desired section of the document, D3 can append an HTML or SVG element onto the section for each element of data. This is where the real power of D3 lies because the user can define the attributes of the element dynamically based on the values of the datum in question. By changing these attributes (e.g. size, radius, color) the resulting document already presents the data in a way that the viewer visually understands. The core also provides support for working with arrays and for defining transitions that can be used to animate the document.

\subsubsection{Further Functionality}

D3 also provides further functionality for manipulating the DOM. Developers can define a scale based on the domain and range of values that are defined in the data provided by the user. The placement of elements within the document can then be placed according to the desired scale. D3 provides support for many different types of scales including linear scales, power scales, logarithmic scales, and temporal scales. Axes can also be created to correspond to the defined scale.

The user has the ability to change the DOM as needed. However, D3 also supports a large number of visualization layouts so that the user does not have to define the positions for the elements in a given visualization. The two layouts that are of relevance for this work are the tree layout and the spring layout.

The tree layout uses the Rheingold-Tilford algorithm for drawing tidy trees \cite{Reingold81}. The force layout uses an algorithm created by Dwyer \cite{Dwyer2009} to create a scalable and constrained graph layout. The physical simulations are based on the work by Jakobsen \cite{Jakobsen03}. The implementation ``uses a quadtree to accelerate charge interaction using the Barnesâ€“Hut approximation. In addition to the repulsive charge force, a pseudo-gravity force keeps nodes centered in the visible area and avoids expulsion of disconnected subgraphs, while links are fixed-distance geometric constraints. Additional custom forces and constraints may be applied on the ``tick'' event, simply by updating the x and y attributes of nodes'' \cite{D3Wiki}.

To help the viewer interact with the visualization, D3 provides support for the zoom and drag behaviors. This listens to the mouse clicks commonly associated with zooming (i.e. scrolling, double clicking) and enlarges the image as would be expected. With this same mechanism, the developer can enable the user to grab hold of the canvas and pan through the image to inspect it closer.

Despite the considerable functions that D3 offers, it is very easy for the user to begin developing with D3. The API is described in detail on the D3 Wiki \cite{D3Wiki}, and the D3 website \cite{D3} includes an extensive array of examples that new developers can use as a jumping off point. The D3 developer community is very large, so it is easy to find answers to almost every question online. 